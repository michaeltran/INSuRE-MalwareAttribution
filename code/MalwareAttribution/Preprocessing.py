import os
import re
import json
import xlsxwriter
import random

def PreProcessing():
    data_folder_path = '../../data'
    static_label_path = data_folder_path + '/static_vt/labels'
    static_data_path = data_folder_path + '/static_vt/compact'
    dynamic_data_path = data_folder_path + '/cuckoo'

    malware_data = {}

    # Get all Malware Hash and Labels
    classification_dict = {}
    for folder_name in os.listdir(static_label_path):
        with open(static_label_path + '/' + folder_name + '/' + folder_name + '_labels.txt', 'r') as file:
            for line in file:
                x = re.findall("(.*)\\t(.*)\\n", line)
                hash = x[0][0]
                label = x[0][1]
                classification_dict[hash] = label

    # Get Malware Dynamic Data (Cuckoo)
    for file_name in os.listdir(dynamic_data_path):
        x = re.findall("coo-(.*).json", file_name)
        hash = x[0]
        classification = classification_dict[hash]
        # Check if Classification is Singleton
        if classification.startswith('SINGLETON'):
            continue
        with open(dynamic_data_path + '/' + file_name, 'r') as file:
            data = json.load(file)

            # Get System Call Data
            behavior_calls_api = []
            if (len(data['behavior']['processes']) > 1):
                behavior_calls = data['behavior']['processes'][1]['calls']
                # TODO: It is very possible for timestamps to be the same, so we should handle this somehow
                behavior_calls = sorted(behavior_calls, key = lambda i: i['time'])
                for calls in behavior_calls:
                    behavior_calls_api.append(calls['api'])

            # Get Network Data
            network_udp_src = []
            network_udp_dst = []
            network_udp_data = data['network']['udp']
            network_udp_data = sorted(network_udp_data, key = lambda i: i['time'])
            for udp in network_udp_data:
                network_udp_src.append(udp['src'] + ':' + str(udp['sport']))
                network_udp_dst.append(udp['dst'] + ':' + str(udp['dport']))
            
            test = ' '.join(behavior_calls_api)
            temp = {}
            temp['classification'] = classification
            temp['behavior_calls'] = ' '.join(behavior_calls_api)
            temp['network_udp_src'] = ' '.join(network_udp_src)
            temp['network_udp_dst'] = ' '.join(network_udp_dst)
            malware_data[hash] = temp

    WriteToExcel(data_folder_path + '/data.xlsx', malware_data)
    # Split Malware Data into Test and Training
    training_malware_data = {}
    testing_malware_data = {}

    training_size = int(len(malware_data) * (9 / 10))

    for i in range(training_size):
        key = random.choice(list(malware_data.keys()))
        training_malware_data[key] = malware_data[key]
        del malware_data[key]

    testing_malware_data = malware_data
    del malware_data

    WriteToExcel(data_folder_path + '/train_data.xlsx', training_malware_data)
    WriteToExcel(data_folder_path + '/test_data.xlsx', testing_malware_data)

def WriteToExcel(path, malware_data):
    with xlsxwriter.Workbook(path) as workbook:
        worksheet = workbook.add_worksheet()
        row = 0;
        col = 0;

        # Header Row
        worksheet.write(row, col, 'classification'); col += 1;
        worksheet.write(row, col, 'hash'); col += 1;
        worksheet.write(row, col, 'behavior_calls'); col += 1;
        worksheet.write(row, col, 'network_udp_src'); col += 1;
        worksheet.write(row, col, 'network_udp_dst'); col += 1;
        row += 1;
        for key in malware_data:
            col = 0;
            worksheet.write(row, col, malware_data[key]['classification']); col += 1;
            worksheet.write(row, col, key); col += 1;
            worksheet.write(row, col, malware_data[key]['behavior_calls']); col += 1;
            worksheet.write(row, col, malware_data[key]['network_udp_src']); col += 1;
            worksheet.write(row, col, malware_data[key]['network_udp_dst']); col += 1;
            row += 1;

if __name__ == '__main__':
    PreProcessing()